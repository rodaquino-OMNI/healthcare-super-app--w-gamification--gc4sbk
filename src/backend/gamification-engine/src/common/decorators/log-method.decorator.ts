import { LoggerService } from 'src/backend/packages/logging/src/logger.service';
import { Injectable } from '@nestjs/common';

/**
 * Log level enum for the LogMethod decorator.
 * Determines the verbosity of the logs generated by the decorator.
 */
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error'
}

/**
 * Options for the LogMethod decorator.
 */
export interface LogMethodOptions {
  /**
   * The log level to use for the method execution logs.
   * @default LogLevel.INFO
   */
  level?: LogLevel;

  /**
   * Whether to log the method parameters.
   * @default true
   */
  logParams?: boolean;

  /**
   * Whether to log the method return value.
   * @default true
   */
  logResult?: boolean;

  /**
   * Whether to log the execution time of the method.
   * @default true
   */
  logExecutionTime?: boolean;

  /**
   * Custom message to include in the log.
   * @default undefined
   */
  message?: string;
}

/**
 * Default options for the LogMethod decorator.
 */
const defaultOptions: LogMethodOptions = {
  level: LogLevel.INFO,
  logParams: true,
  logResult: true,
  logExecutionTime: true
};

/**
 * Decorator that logs method execution details including input parameters,
 * return values, and execution time. Enhances observability by providing
 * consistent, structured logging across the gamification engine.
 * 
 * @param options Configuration options for the decorator
 * @returns Method decorator
 * 
 * @example
 * // Basic usage with default options (INFO level)
 * @LogMethod()
 * async findAll(): Promise<Achievement[]> {
 *   // Method implementation
 * }
 * 
 * @example
 * // With custom log level and options
 * @LogMethod({
 *   level: LogLevel.DEBUG,
 *   logParams: true,
 *   logResult: false,
 *   message: 'Custom processing logic'
 * })
 * async processEvent(event: ProcessEventDto): Promise<any> {
 *   // Method implementation
 * }
 */
export function LogMethod(options: LogMethodOptions = {}): MethodDecorator {
  // Merge provided options with defaults
  const config = { ...defaultOptions, ...options };

  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    // Store the original method
    const originalMethod = descriptor.value;

    // Replace the original method with our wrapped version
    descriptor.value = async function (...args: any[]) {
      // Get the logger instance from the class instance if available
      // or try to get it from the global container
      let logger: LoggerService;
      if (this.logger && this.logger instanceof LoggerService) {
        logger = this.logger;
      } else {
        try {
          // Try to get the logger from the global container
          const container = (global as any).nestContainer;
          if (container) {
            logger = container.get(LoggerService);
          }
        } catch (error) {
          // If we can't get the logger, create a minimal implementation
          // that logs to console as a fallback
          logger = {
            log: (message: string, context?: string) => console.log(`[INFO] [${context}] ${message}`),
            error: (message: string, trace?: string, context?: string) => 
              console.error(`[ERROR] [${context}] ${message}`, trace),
            warn: (message: string, context?: string) => console.warn(`[WARN] [${context}] ${message}`),
            debug: (message: string, context?: string) => console.debug(`[DEBUG] [${context}] ${message}`),
            verbose: (message: string, context?: string) => console.log(`[VERBOSE] [${context}] ${message}`)
          } as LoggerService;
        }
      }

      // Get class name and method name for context
      const className = this.constructor.name;
      const methodName = propertyKey.toString();
      const context = `${className}.${methodName}`;

      // Extract request context if available
      const requestId = this.request?.id || 'unknown';
      const userId = this.request?.user?.id || this.userId || 'unknown';
      const journey = this.request?.journey || this.journey || 'unknown';

      // Create a context-enriched log prefix
      const contextInfo = `[ReqID:${requestId}] [UserID:${userId}] [Journey:${journey}]`;
      
      // Prepare start message
      let startMessage = config.message 
        ? `${contextInfo} ${config.message} - Started` 
        : `${contextInfo} Executing ${methodName}`;

      // Add parameters if configured
      if (config.logParams && args.length > 0) {
        try {
          // Sanitize parameters to avoid logging sensitive information
          const sanitizedArgs = args.map(arg => {
            if (arg && typeof arg === 'object') {
              // Create a shallow copy to avoid modifying the original
              const sanitized = { ...arg };
              
              // Mask sensitive fields
              ['password', 'token', 'secret', 'credential', 'authorization']
                .forEach(field => {
                  if (field in sanitized) {
                    sanitized[field] = '***REDACTED***';
                  }
                });
              
              return sanitized;
            }
            return arg;
          });
          
          startMessage += ` - Parameters: ${JSON.stringify(sanitizedArgs)}`;
        } catch (error) {
          startMessage += ` - Parameters: [Error serializing parameters: ${error.message}]`;
        }
      }

      // Log method start based on configured level
      switch (config.level) {
        case LogLevel.DEBUG:
          logger.debug(startMessage, context);
          break;
        case LogLevel.WARN:
          logger.warn(startMessage, context);
          break;
        case LogLevel.ERROR:
          logger.error(startMessage, null, context);
          break;
        case LogLevel.INFO:
        default:
          logger.log(startMessage, context);
          break;
      }

      // Record start time if execution time logging is enabled
      const startTime = config.logExecutionTime ? Date.now() : 0;

      try {
        // Execute the original method
        const result = await originalMethod.apply(this, args);

        // Calculate execution time if enabled
        const executionTime = config.logExecutionTime ? Date.now() - startTime : 0;
        
        // Prepare completion message
        let completionMessage = config.message
          ? `${contextInfo} ${config.message} - Completed`
          : `${contextInfo} ${methodName} executed successfully`;

        // Add execution time if configured
        if (config.logExecutionTime) {
          completionMessage += ` - Execution time: ${executionTime}ms`;
        }

        // Add result if configured
        if (config.logResult && result !== undefined) {
          try {
            // For large objects, limit the output
            const resultStr = JSON.stringify(result);
            const truncatedResult = resultStr.length > 1000 
              ? resultStr.substring(0, 997) + '...'
              : resultStr;
            
            completionMessage += ` - Result: ${truncatedResult}`;
          } catch (error) {
            completionMessage += ` - Result: [Error serializing result: ${error.message}]`;
          }
        }

        // Log method completion based on configured level
        switch (config.level) {
          case LogLevel.DEBUG:
            logger.debug(completionMessage, context);
            break;
          case LogLevel.WARN:
            logger.warn(completionMessage, context);
            break;
          case LogLevel.ERROR:
            logger.error(completionMessage, null, context);
            break;
          case LogLevel.INFO:
          default:
            logger.log(completionMessage, context);
            break;
        }

        // Return the original result
        return result;
      } catch (error) {
        // Calculate execution time until error if enabled
        const executionTime = config.logExecutionTime ? Date.now() - startTime : 0;
        
        // Prepare error message
        let errorMessage = config.message
          ? `${contextInfo} ${config.message} - Failed`
          : `${contextInfo} ${methodName} execution failed`;

        // Add execution time if configured
        if (config.logExecutionTime) {
          errorMessage += ` - Failed after ${executionTime}ms`;
        }

        // Add error details
        errorMessage += ` - Error: ${error.message}`;

        // Always log errors with ERROR level regardless of configured level
        logger.error(errorMessage, error.stack, context);

        // Re-throw the error to maintain the original behavior
        throw error;
      }
    };

    return descriptor;
  };
}